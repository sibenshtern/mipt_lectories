# Архитектура компьютеров и операционные системы (лекции) <!-- omit in toc -->

- [Исторический экскурс в операционные системы](#исторический-экскурс-в-операционные-системы)
- [Оболочка](#оболочка)
  - [Что это такое:](#что-это-такое)
- [Системные вызовы](#системные-вызовы)
- [Систаксис команд Unix](#систаксис-команд-unix)
  - [Команда и аргументы](#команда-и-аргументы)
  - [Перенаправление ввода-вывода](#перенаправление-ввода-вывода)
  - [Подстановки в оболочке (shell expansions)](#подстановки-в-оболочке-shell-expansions)
- [Процессы в Unix](#процессы-в-unix)
  - [Контекст процесса](#контекст-процесса)
  - [Иерарзия процессов](#иерарзия-процессов)
  - [Команды управления процессами в Linux](#команды-управления-процессами-в-linux)
  - [Диаграмма состояний процессора](#диаграмма-состояний-процессора)
  - [Планирование](#планирование)
  - [Системный вызов для PID](#системный-вызов-для-pid)
  - [Создание процесса в Unix](#создание-процесса-в-unix)
  - [Системный вызов создания процесса](#системный-вызов-создания-процесса)
  - [Использование fork()](#использование-fork)
  - [Завершение процесса](#завершение-процесса)
  - [Процесс в представлении С](#процесс-в-представлении-с)
  - [Изменение контекста процесса](#изменение-контекста-процесса)
  - [Использование exec()](#использование-exec)

## Исторический экскурс в операционные системы

Операционная система - `Unix-подобная`

Мы будем говорить про многозадачность, многопользовательность, файловую систему, сетевые системы, виртуальная память, распараллеливание, ввод-вывод.

Изучаем с использованием языка `С`. 

Книги:
  + Основы операционных систем. Карпов, Коньков

**MultICS** - Multiplexed Information and Computing Service.

С 1964 по 1969 год **Multics** пытались разработать операционные системы. Этим занимались Bell Labs, MIT, General Electric.

В 1969 **AT&T** создают систему **UniCS**. Потом **CS** перешла в **X** и получилась **Unix**. Её разрабатывали Кен Томпсон, Деннис Ритчи и другими. В 1969 году появилась система **Unix Edition. 1**. В 1973 появился язык Си. В 1974 году вся система была переписана на Си.

1975 год - **Unix Edition 5 (Unix System V)**.

1978 год - **Unix Edition 7**.

## Оболочка

### Что это такое:

- Командный интерпретатор
- Текстовый интерфейс командной строки
- Запуск программ, выполняющих полезные действия
- Автоматизация действий в виде программ

## Системные вызовы

- Прямые точки входа пользовательских процессов в ядро  
- Выполняются в привилегированном режиме для доступа к системным данным/устройствам
- Реализованы по разному в различных ядрах
- Отображаются в вызовы функций языка `С` -> интерфейс системных вызовов -> стандартная UNIX-библиотека `libc`
- Стандарт POSIX - **P**ortable **O**perating **S**ystem **I**nterface

От библиотеки `libc` зависят все программы, выполняющиеся в Linux 

```c
#include <unistd.h> // <- int getuid()
#include <stdio.h> // <- void perror(char *)

int main() {
    int ret = getuid();
    perror("getuid result");
    return ret;
}
```

- Возвращаем значение 
  - `-1` - ошибка
  - `>= 0` - успех
- Точный код ошибка - в глобальной переменной `errno`
- При успешном завершении errno не меняется
- Расщифровка последнего кода ошибки - функция `perror(char *)` - выводит расшифровку по коду ошибки из глобальной переменной `errno` (перед этим подставляет `char *`)

## Систаксис команд Unix

### Команда и аргументы

`command arg1 arg2 ... argN`

1. **Аргументы, как опции**
  - Короткий формат:
    + `-a`
    + `-A`
    + `-bc`
  - Длинный формат:
    + `--help`
    + `--verbose`
2. **Типичное описание в документации**

`command [arg1] [arg2] arg3`

- `arg1` - необязательный аргумент `arg1`
- `arg3` - обязательный аргумент `arg3`

Короткие опции можно соединять в несколько, например не `-l -a`, а `-la`, стандарт для опций не существует.

Практически во всех командах существует опция `--help`

`man` - Manual

### Перенаправление ввода-вывода

**Вывод в файл:**
`cmd1 -a -b > out_file`
`cmd1 -c -d >> out_file`

**Считывание из файла:**
`cmd1 -e -f < in_file`

**Конвейер:**
`cmd1 -g -h | cmd2`

### Подстановки в оболочке (shell expansions)

В командной строке оболочка заменяет конструкции со спецсимволами **\***, **?**, **$**, **{}**, **[]**

1. `a*z`
   - заменяется на список имён файлов, имеющихся в текущем каталоге, соответствующих шаблону
   - подходят `az`, `abcz`, `a_z`, ...
   - `*` - любое количество любых символов
2. `a?z`
   - заменяется на список файлов имеющихся в текущем каталоге, соответствующих шаблону
   - подходят `abz`, `acz`
   - **не** подходят `az`, `abcz`
   - `?` - один любой символ
3. `a[b-d]z`
   - список файлов из текущего каталога по шаблону
   - `[]` - один любой символ из перечисленных
4. `a{bd, ed, gf}z`
   - генерирует список `abcz`, `adez`, `agfz`
   - безотносительно к файлам или текущему каталогу
5. `$var`
   - подставляет значение перменной по имени `var`
   - задать значение как `var=value` 

## Процессы в Unix

**Процесс** - программ + входные данные + момент исполнения

Процесс - совокупность:
- набора исполняющихся команд
- ассоциированных ресурсов (выделенная память, адресное пространство, стеки, файлы, устройства ввода-вывода и т. д.)
- текущего момента выполнения (значения регистров, программного счётчика, состояние стека, значения переменных и т. д.) под управлением операционной системы

Всё, что выполняется в Unix - процесс

### Контекст процесса

**Контекст** = пользовательский + ядерный

**Контекст ядра** = регистровый контекст + системный стек ядра + данные ядра

**Данные ядра (PCB Process Control Block):**
- идентификатор процесса PID
- идентификатор родительского процесса PPID
- идентификатор пользователя UID
- идентификатор группы GID

### Иерарзия процессов

- Каждый процесс порождается другим
- Создающий процесс - родитель (parent process)
- Сосздаваемый процесс - ребёнок, "дочерний процесс" (child process)
- Идентификатор процесса в Unix - **PID** - уникальное число $2^{31} - 1$

### Команды управления процессами в Linux

- `ps` - мгновенный ссписок процессов, запущенных текущими пользователем в текущем терминале
- `ps -eF` (`ps aux`) - мгновенный список всех процессов в системе в расширенном формате
- `top` - динамический список работающих процессов
- `htop` - динамический список процессов с интерфейсом

### Диаграмма состояний процессора

![Процессы](../images/processes.svg)

### Планирование

Планировщик процессов учитывает множество факторов: сколько процесс потреблял ресурсы, сколько времени работает и т. д.

### Системный вызов для PID

```c
#include <sys/types.h>
#include <unistd.h>

pid_t getpid(void);
pid_t getppid(void);
```

### Создание процесса в Unix

1. Скопировать весь контекст (copy-on-write)
2. Возможно настроить окружение
3. Заменить пользовательский контекст

![Создание процессов в Unix](../images/createprocess.svg)

### Системный вызов создания процесса 

```c
#include <sys/types.h>
#include <unistd.h>

pid_t fork();
```

### Использование fork()

```c
pid_t pid = fork();

if (pid > 0) {
  // родитель
} else if (pid == 0) {
  // ребенок
} else {
  // ошибка
}
```

После выхода из `fork()` продолжается исполнение следующего за вызовом кода (одинакового!), как в родителе, так и в ребёнке

Ветви исполнения кода в родителе и ребёнке можно разделить по возвращаемому значению

### Завершение процесса 

```c
#include <stdlib.h>

void exit(int status);
```

Нормальное завершение процесса - закрытие файлов, опустошение буферов, перевод в состояние "закончил исполнение"

Возврата в программу НЕТ

status - /\*дописать\*/

Если родитель завершается раньше ребенка: ребенок получает PPID = 1, т. е. родителем становится PID = 1 (головной процесс `init` или `systemd`)

Если родитель не запрашивает информацию о завершении: ребенок остаётся в состоянии "завершил исполнение" = процесс-зомби (zombie, defunct)

### Процесс в представлении С

```c
int main(
  int argc,
  char *argv[],
  char *envp[]
) {
  
  ... 
  
  return err_code;
}
```

- `main()` - точка входа
- `return err_code;` - из `main()` - вызов exit(err_code)
- Параметры передаются из ОС при запуске
  - `argc` - количество слов-аргументов в командрной строке (argument count)
  - `argv[]` - массив слов в "командной строке" (argument values)
  - `envp[]` - список переменных окружения, строк в виде "var=value"
```bash
./cmd -o abc 123
```

- `./cmd` - argv[0]
- `-o` - argv[1]
- `abc` - argv[2]
- `123` - argv[3]

`argc` = 4

### Изменение контекста процесса

```c
#include <unistd.h>

int execl(const char *path, const char *arg, ..., NULL);

int execlp(const char *path, const char *arg, ..., NULL);

int execle(const char *path, const char *arg, ..., NULL, char * const envp[]);

int execv(const char *path, char *const argv[]);

int execvp(const char *path, char *const argv[]);

int execve(const char *path, char *const argv[], char *const envp[]);
```

- Уничтожает(!) текущий пользовательский контекст и заменяет его на загружаемый из исполняемого файла
- Возвращает:
  - -1 - при ошибке
  - НЕ возвращается при успехе
- `file` - имя исполняемого бинарного(!) файла, автопоиск в стандартных
- `path` - путь к исполняемому бинарному(!) файлу (каталог + имя)

### Использование exec()

```c
#include <unistd.h>

int main(int argc, char *argv[], char *envp[]) {
  pid_t p = fork();

  if (p == -1) { perror("fork"); return -1; }
  if (p == 0) {
    int ret = execle("/bin/ls", "ls", "-l", NULL, envp);
    if (ret == -1) { perror("exec"); return -2; }
  }
  return 0;s
}
```